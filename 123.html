<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Hill Climb Racing</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #87CEEB;
  }
  canvas {
    display: block;
    background: linear-gradient(#87CEEB, #c0eaff);
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// --- Einstellungen ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = innerWidth;
canvas.height = innerHeight;

let keys = {};
let gravity = 0.04;
let friction = 0.98;

// --- Spielerauto ---
let car = {
  x: 200,
  y: 300,
  width: 60,
  height: 20,
  wheelRadius: 10,
  speedX: 0,
  speedY: 0,
  rotation: 0,
  onGround: false
};

// --- Strecke generieren ---
const hillLength = 1000;
let terrain = [];
let lastY = canvas.height * 0.7;
for (let x = 0; x < hillLength; x++) {
  lastY += Math.sin(x * 0.1) * 10 + (Math.random() - 0.5) * 10;
  terrain.push({x: x * 20, y: lastY});
}

let cameraX = 0;

// --- Steuerung ---
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// --- Hauptupdate ---
function update() {
  // Bewegung
  if (keys['ArrowRight']) car.speedX += 0.3;
  if (keys['ArrowLeft']) car.speedX -= 0.3;
  if (keys[' ']) car.speedY = -8; // Sprung (Testweise)

  car.speedX *= friction;
  car.x += car.speedX;
  car.y += car.speedY;
  car.speedY += gravity;

  // Boden finden (einfachster Ansatz)
  let groundY = getGroundY(car.x);
  if (car.y + car.height / 2 > groundY) {
    car.y = groundY - car.height / 2;
    car.speedY = 0;
    car.onGround = true;
    // compute terrain slope around car.x and set car rotation to match (smoothly)
    const delta = 1; // small sample distance in world units
    const y1 = getGroundY(car.x - delta);
    const y2 = getGroundY(car.x + delta);
    const slope = Math.atan2(y2 - y1, (delta * 2));
    // smooth interpolation so rotation doesn't snap
    const blend = 0.2;
    car.rotation += (slope - car.rotation) * blend;
  } else {
    car.onGround = false;
  }

  // Kamera folgt Auto
  cameraX = car.x - canvas.width / 2;

  draw();
  requestAnimationFrame(update);
}

// --- Bodenhöhe ermitteln ---
function getGroundY(x) {
  let index = Math.floor(x / 20);
  if (index < 0) index = 0;
  if (index >= terrain.length - 1) return terrain[terrain.length - 1].y;
  let t1 = terrain[index], t2 = terrain[index + 1];
  let ratio = (x - t1.x) / (t2.x - t1.x);
  return t1.y + (t2.y - t1.y) * ratio;
}

// --- Zeichnen ---
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Boden zeichnen
  ctx.beginPath();
  ctx.moveTo(terrain[0].x - cameraX, terrain[0].y);
  for (let i = 1; i < terrain.length; i++) {
    ctx.lineTo(terrain[i].x - cameraX, terrain[i].y);
  }
  ctx.lineTo(terrain[terrain.length - 1].x - cameraX, canvas.height);
  ctx.lineTo(0 - cameraX, canvas.height);
  ctx.closePath();
  ctx.fillStyle = '#228B22';
  ctx.fill();


  // Auto zeichnen (zentriert am Fahrzeugmittelpunkt, mit Rotation)
  ctx.save();
  // translate to car center in screen coords
  ctx.translate(car.x - cameraX, car.y);
  ctx.rotate(car.rotation);

  // Räder (relative to rotated car center)
  const wheelOffset = car.width / 3;
  const wheelY = car.height / 2;
  ctx.fillStyle = "#222";
  ctx.beginPath();
  ctx.arc(wheelOffset, wheelY, car.wheelRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-wheelOffset, wheelY, car.wheelRadius, 0, Math.PI * 2);
  ctx.fill();

  // Karosserie (centered at 0,0)
  ctx.fillStyle = "#ff3333";
  ctx.fillRect(-car.width/2, -car.height/2, car.width, car.height);

  ctx.restore();

  // HUD
  ctx.fillStyle = "black";
  ctx.font = "20px Arial";
  ctx.fillText("Geschwindigkeit: " + car.speedX.toFixed(1), 20, 30);
}

// Start
update();
</script>
</body>
</html>
