<!doctype html>
<html lang="de">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Hillclimb - Prozedurale Hügel-Map</title>
	<style>
		html,body{height:100%;margin:0}
		canvas{display:block;background:#87CEEB; /* Himmelblau */}
		#ui{
			position:fixed;left:12px;top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.85);font-family:Arial,Helvetica,sans-serif;font-size:13px;color:#133;
			box-shadow:0 2px 8px rgba(0,0,0,0.15);
		}
		#legend{opacity:0.9}
		a{color:#064}
	</style>
</head>
<body>
	<canvas id="c"></canvas>
	<div id="ui">
		<div id="legend">
			<strong>Prozedurale Hügel-Map</strong><br>
			Pfeiltasten ← → : nach links/rechts scrollen<br>
			Leertaste : Auto-Scroll ein/aus<br>
			+ / - : Zoom (Hügelskala)<br>
			R : Zufalls-Seed neu
		</div>
		<div style="margin-top:8px; font-size:12px; color:#064">Seed: <span id="seed">—</span></div>
	</div>

	<script>
	// ====== Einstellungen ======
	const cfg = {
		pointSpacing: 6,       // Pixel zwischen Abtastpunkten (kleiner = feinere Hügel)
		baseAmplitude: 140,    // Grundhöhe der Hügel
		baseFreq: 0.0018,      // Grundfrequenz der Noise (größere = mehr Hügel)
		octaves: 5,            // Anzahl der FBM-Octaves
		lacunarity: 2.0,       // Frequenzverhältnis zwischen Octaves
		gain: 0.5,             // Amplitudenabnahme pro Octave
		autoSpeed: 120,        // Pixel pro Sekunde bei Auto-Scroll
		hillColorTop: '#67c34a',
		hillColorBottom: '#2e8b2e'
	};

	// ====== Canvas Setup ======
	const canvas = document.getElementById('c');
	const ctx = canvas.getContext('2d');
	let W = 0, H = 0;
	function resize(){
		W = canvas.width = window.innerWidth;
		H = canvas.height = window.innerHeight;
		draw();
	}
	window.addEventListener('resize', resize, {passive:true});

	// ====== Deterministisches Hash / PRNG für Noise ======
	// Hashfunktion für Ganzzahlen -> deterministischer Pseudozufall in [-1,1]
	function intHash(n){
		// 32-bit integer mix
		n = (n|0) + 0x7ed55d16 + (n<<12)|0;
		n = (n ^ 0xc761c23c) ^ (n>>>19);
		n = (n + 0x165667b1) + (n<<5); n = (n+0xd3a2646c) ^ (n<<9);
		n = (n + 0xfd7046c5) + (n<<3); n = (n ^ 0xb55a4f09) ^ (n>>>16);
		return (n>>>0) / 4294967295 * 2 - 1;
	}

	// ====== 1D Value-Noise mit glatter Interpolation ======
	function smoothstep(t){ return t*t*(3-2*t); }
	function valueNoise1D(x){
		const ix = Math.floor(x);
		const fx = x - ix;
		const a = intHash(ix);
		const b = intHash(ix+1);
		const t = smoothstep(fx);
		return a*(1-t) + b*t;
	}

	// ====== Fractal Brownian Motion (FBM) aus mehreren Octaves ======
	function fbm1D(x, octaves=cfg.octaves){
		let amp = 1, freq = 1, sum = 0, norm = 0;
		for(let i=0;i<octaves;i++){
			sum += amp * valueNoise1D(x*freq);
			norm += amp;
			amp *= cfg.gain;
			freq *= cfg.lacunarity;
		}
		return sum / norm;
	}

	// ====== Höhenfunktion (weltweit) ======
	function heightAt(x){
		// x in Welt-Pixel
		const nx = x * cfg.baseFreq;
		const n = fbm1D(nx, cfg.octaves);
		// leicht non-linear: mehr Variation bei Hügelkuppen
		const h = (n*0.9 + Math.sin(nx*0.5)*0.06) * cfg.baseAmplitude;
		// Basishöhe (Bodenhöhe) etwas unter Bildmitte
		return H*0.55 - h;
	}

	// ====== Rendering ======
	let viewX = 0;          // Welt-Koordinate (linke Bildschirmkante)
	let autoScroll = true;
	let lastT = performance.now();

	function draw(){
		ctx.clearRect(0,0,W,H);
		// Himmel-Gradient
		const g = ctx.createLinearGradient(0,0,0,H);
		g.addColorStop(0,'#9EE3FF');
		g.addColorStop(1,'#7AC0FF');
		ctx.fillStyle = g;
		ctx.fillRect(0,0,W,H);

		// Parallax: einfache entfernte Hügel auf Hintergrund
		drawParallaxHills(viewX*0.3, 0.25, 220, '#b6e1a1', '#8fc07c');

		// Vordergrund-Hügel
		ctx.beginPath();
		const spacing = cfg.pointSpacing;
		// Start außerhalb Canvas links, damit Kanten sauber sind
		const extra = 60;
		let first = true;
		for(let sx = -extra; sx <= W + extra; sx += spacing){
			const wx = viewX + sx;
			const hy = heightAt(wx);
			if(first){ ctx.moveTo(sx, hy); first=false; }
			else ctx.lineTo(sx, hy);
		}
		// Schließe Pfad zum unteren Rand
		ctx.lineTo(W+extra, H);
		ctx.lineTo(-extra, H);
		ctx.closePath();

		// Farbverlauf für Hügel
		const hg = ctx.createLinearGradient(0, H*0.25, 0, H);
		hg.addColorStop(0, cfg.hillColorTop);
		hg.addColorStop(1, cfg.hillColorBottom);
		ctx.fillStyle = hg;
		ctx.fill();

		// Kante/Outline
		ctx.strokeStyle = 'rgba(0,60,0,0.6)';
		ctx.lineWidth = 2;
		ctx.beginPath();
		let firstLine = true;
		for(let sx = -extra; sx <= W + extra; sx += spacing){
			const wx = viewX + sx;
			const hy = heightAt(wx);
			if(firstLine){ ctx.moveTo(sx, hy); firstLine=false; }
			else ctx.lineTo(sx, hy);
		}
		ctx.stroke();

		// Optional: eine einfache Boden-Markierung (für Orientierung)
		ctx.fillStyle = 'rgba(0,0,0,0.06)';
		ctx.fillRect(12, H-36, 120, 2);
	}

	function drawParallaxHills(offset, amplitudeFactor, baseAmp, topColor, bottomColor){
		ctx.save();
		ctx.globalAlpha = 0.95;
		ctx.beginPath();
		const spacing = Math.max(8, cfg.pointSpacing*2);
		const extra = 40;
		let first = true;
		for(let sx = -extra; sx <= W + extra; sx += spacing){
			const wx = offset + sx;
			const n = fbm1D(wx*cfg.baseFreq*0.6, 4);
			const hy = H*0.6 - (n * baseAmp * amplitudeFactor);
			if(first){ ctx.moveTo(sx, hy); first=false;} else ctx.lineTo(sx, hy);
		}
		ctx.lineTo(W+extra, H);
		ctx.lineTo(-extra, H);
		ctx.closePath();
		const g = ctx.createLinearGradient(0, H*0.4, 0, H);
		g.addColorStop(0, topColor);
		g.addColorStop(1, bottomColor);
		ctx.fillStyle = g;
		ctx.fill();
		ctx.restore();
	}

	// ====== Vehicle (2D Auto) + Physics ======
	// Controls: D = vorwärts, A = rückwärts
	const keys = { a:false, d:false };
	window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='d') keys.d = true; if(e.key.toLowerCase()==='a') keys.a = true; });
	window.addEventListener('keyup', (e)=>{ if(e.key.toLowerCase()==='d') keys.d = false; if(e.key.toLowerCase()==='a') keys.a = false; });

	// Simple car model
	const car = {
		x: 300,
		y: 0,
		vx: 0, vy: 0,
		angle: 0, omega: 0,
		mass: 26,                    // etwas schwerer für mehr Trägheit
		inertia: 4000,               // deutlich höhere Trägheit reduziert Drehung
		width: 140, height: 30,
		wheelRadius: 24,
		wheelMass: 5,
		wheels: [ {ox:-44, oy:18, angVel:0}, {ox:44, oy:18, angVel:0} ],
		suspension: { rest: 28, k: 9000, damping: 3500 }, // weichere Feder, stärkere Dämpfung
		driveTorque: 0
	};
	car.wheelInertia = 0.5 * car.wheelMass * car.wheelRadius * car.wheelRadius;

	// place car on ground initially (after canvas size is known)
	car.y = heightAt(car.x) - 80;

	// place car on ground initially (after canvas size is known)
	car.y = heightAt(car.x) - 80;

	// physics constants
	const GRAV = 2200; // pixels / s^2
	const airDrag = 1.2; // etwas mehr Luftwiderstand für Stabilität

	function worldToScreenX(wx){ return wx - viewX; }

	function updatePhysics(dt){
		// apply control torque
		const maxTorque = 1000; // reduziertes Drehmoment -> weniger Rotation
		let torque = 0;
		if(keys.d) torque += maxTorque;
		if(keys.a) torque -= maxTorque * 0.6;

		// reset accumulators
		let totalFx = 0, totalFy = 0, totalTorque = 0;

		// gravity on chassis
		totalFy += car.mass * GRAV;

		// chassis linear vel and ang vel are car.vx, car.vy, car.omega
		for(let i=0;i<car.wheels.length;i++){
			const w = car.wheels[i];
			// wheel world position
			const cos = Math.cos(car.angle), sin = Math.sin(car.angle);
			const rx = w.ox * cos - w.oy * sin;
			const ry = w.ox * sin + w.oy * cos;
			const wx = car.x + rx;
			const wy = car.y + ry;

			// wheel linear velocity = chassis velocity + omega x r
			const pvx = car.vx - car.omega * ry;
			const pvy = car.vy + car.omega * rx;

			// terrain contact
			const terrainY = heightAt(wx);
			// approximate surface slope (dh/dx)
			const eps = 1;
			const hL = heightAt(wx - eps);
			const hR = heightAt(wx + eps);
			const slope = (hR - hL) * 0.5 / eps; // dh/dx (canvas coords)
			// normal vector pointing UP (negative y in canvas): (-slope, -1)
			let nx = -slope, ny = -1;
			let nlen = Math.hypot(nx, ny);
			nx /= nlen; ny /= nlen;

			const bottomY = wy + car.wheelRadius;
			if(bottomY > terrainY){
				let penetration = bottomY - terrainY;
				// clamp penetration to avoid explosive springs on large teleport
				penetration = Math.min(penetration, 40);
				// relative velocity along normal
				const velAlongN = pvx * nx + pvy * ny;
				// suspension spring force (magnitude)
				const fs = car.suspension.k * penetration;
				// damping opposing compression velocity along the normal
				const fd = car.suspension.damping * Math.max(0, -velAlongN);
				let Fn = fs + fd;
				// safety clamp
				Fn = Math.min(Fn, car.mass * GRAV * 8);

				// force vector (Fx,Fy) — note: ny is negative for upward
				const Fx = Fn * nx;
				const Fy = Fn * ny;

				// add to chassis accumulators (positive y is downwards, Fx as is)
				totalFx += Fx;
				totalFy += Fy;
				// torque on chassis from force at r: tau = r_x * F_y - r_y * F_x
				totalTorque += rx * Fy - ry * Fx;

				// tangent (along surface) is perpendicular to normal
				const tx = -ny; const ty = nx; // rotate normal by +90deg
				// wheel ground relative tangential velocity (contact point): v_t = v_point dot t
				const vPointT = pvx * tx + pvy * ty;
				const wheelSpinSpeed = w.angVel * car.wheelRadius; // linear speed at rim
				const slip = wheelSpinSpeed - vPointT; // positive means wheel spins faster than ground

				// traction from engine torque (split to two wheels)
				const driveForce = torque * 0.5 / car.wheelRadius;

				// simple friction model (viscous + Coulomb-ish)
				const mu = 0.9;
				const Ft_max = Fn * mu;
				const visc = 400;
				let Ft = driveForce - slip * visc;
				if(Ft > Ft_max) Ft = Ft_max;
				if(Ft < -Ft_max) Ft = -Ft_max;

				// apply tangential force
				const Fx_t = Ft * tx;
				const Fy_t = Ft * ty;
				totalFx += Fx_t; totalFy += Fy_t;
				totalTorque += rx * Fy_t - ry * Fx_t;

				// wheel angular acceleration due to torque and ground reaction
				const wheelAlpha = ( (torque*0.5) - Ft * car.wheelRadius ) / car.wheelInertia;
				w.angVel += wheelAlpha * dt;
				// stronger rolling resistance for stability
				w.angVel *= (1 - Math.min(0.98, dt * 4.0));
			} else {
				// airborne wheel -> wheel spins freely with small air drag
				w.angVel *= (1 - Math.min(0.9, dt * 0.3));
			}
		}

		// integrate chassis linear
		const ax = totalFx / car.mass;
		const ay = totalFy / car.mass;
		car.vx += ax * dt;
		car.vy += ay * dt;
		// air drag
		car.vx *= Math.exp(-airDrag * dt);
		car.vy *= Math.exp(-airDrag * dt);

		car.x += car.vx * dt;
		car.y += car.vy * dt;

		// integrate angular
		const aalpha = totalTorque / car.inertia;
		car.omega += aalpha * dt;
		// exponential damping on angular velocity (stronger)
		car.omega *= Math.exp(-6.0 * dt);
		// clamp angular speed to avoid explosions
		const maxOmega = 6.0; // rad/s
		if(car.omega > maxOmega) car.omega = maxOmega;
		if(car.omega < -maxOmega) car.omega = -maxOmega;
		car.angle += car.omega * dt;

		// keep car above a minimum to avoid falling through on startup
		if(!isFinite(car.x) || !isFinite(car.y)){
			car.x = Math.max(100, car.x||300);
			car.y = heightAt(car.x) - 80;
			car.vx = car.vy = car.omega = 0;
		}
	}

	function drawCar(){
		const sx = worldToScreenX(car.x);
		const sy = car.y;
		ctx.save();
		ctx.translate(sx, sy);
		ctx.rotate(car.angle);
		// chassis
		ctx.fillStyle = 'linear-gradient';
		// body gradient
		const g = ctx.createLinearGradient(-car.width/2, -car.height, car.width/2, car.height);
		g.addColorStop(0, '#ef5b5b');
		g.addColorStop(1, '#b22222');
		ctx.fillStyle = g;
		ctx.beginPath();
		const r = 8;
		ctx.moveTo(-car.width/2 + r, -car.height/2);
		ctx.lineTo(car.width/2 - r, -car.height/2);
		ctx.quadraticCurveTo(car.width/2, -car.height/2, car.width/2, -car.height/2 + r);
		ctx.lineTo(car.width/2, car.height/2 - r);
		ctx.quadraticCurveTo(car.width/2, car.height/2, car.width/2 - r, car.height/2);
		ctx.lineTo(-car.width/2 + r, car.height/2);
		ctx.quadraticCurveTo(-car.width/2, car.height/2, -car.width/2, car.height/2 - r);
		ctx.lineTo(-car.width/2, -car.height/2 + r);
		ctx.quadraticCurveTo(-car.width/2, -car.height/2, -car.width/2 + r, -car.height/2);
		ctx.closePath();
		ctx.fill();
		// windows
		ctx.fillStyle = 'rgba(255,255,255,0.18)';
		ctx.fillRect(-20, -car.height/2 + 2, 40, 14);

		// wheels
		for(let i=0;i<car.wheels.length;i++){
			const w = car.wheels[i];
			const rx = w.ox, ry = w.oy;
			ctx.save();
			ctx.translate(rx, ry);
			ctx.rotate(w.angVel * 0.25); // visual rotation (scaled)
			// rim
			ctx.beginPath(); ctx.fillStyle = '#222'; ctx.arc(0,0,car.wheelRadius,0,Math.PI*2); ctx.fill();
			ctx.beginPath(); ctx.fillStyle = '#555'; ctx.arc(0,0,car.wheelRadius*0.6,0,Math.PI*2); ctx.fill();
			ctx.restore();
		}
		ctx.restore();
	}

	// ====== Animation Loop ======
	function loop(t){
		const dt = Math.min(40, t - lastT) / 1000; // Sek
		lastT = t;
		// disable autoScroll by default when using car
		if(autoScroll) viewX += cfg.autoSpeed * dt;
		// physics update
		updatePhysics(dt);
		// camera follow
		viewX = car.x - W * 0.36;
		draw();
		// draw car on top
		drawCar();
		requestAnimationFrame(loop);
	}

	// ====== Input ======
	window.addEventListener('keydown', (e)=>{
		if(e.key === 'ArrowRight'){ viewX += 120; draw(); }
		else if(e.key === 'ArrowLeft'){ viewX -= 120; draw(); }
		else if(e.key === ' '){ autoScroll = !autoScroll; e.preventDefault(); }
		else if(e.key === '+') { cfg.baseAmplitude *= 1.12; draw(); }
		else if(e.key === '-') { cfg.baseAmplitude /= 1.12; draw(); }
		else if(e.key.toLowerCase() === 'r'){ setSeed((Math.random()*1e9)|0); }
	});

	// Pointer Drag to pan
	let dragging=false, startX=0, startViewX=0;
	canvas.addEventListener('pointerdown', e=>{ dragging=true; startX=e.clientX; startViewX=viewX; canvas.setPointerCapture(e.pointerId); });
	canvas.addEventListener('pointerup', e=>{ dragging=false; canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); });
	canvas.addEventListener('pointermove', e=>{ if(dragging){ viewX = startViewX - (e.clientX - startX); draw(); }});

	// ====== Seed Handling (für deterministische Map) ======
	let userSeed = 12345;
	function setSeed(s){ userSeed = s|0; // set global seed by adjusting intHash closure via offset
		// We'll integrate seed by offsetting hash input globally
		// Implement by remapping intHash to include seed in the mix.
		// To keep code simple, replace intHash with a seeded wrapper:
		intHash = function(n){
			// combine n with seed
			const v = ((n|0) ^ (userSeed|0)) + 0x9e3779b9;
			let x = v|0;
			x = (x + 0x7ed55d16 + (x<<12))|0;
			x = (x ^ 0xc761c23c) ^ (x>>>19);
			x = (x + 0x165667b1) + (x<<5);
			x = (x + 0xd3a2646c) ^ (x<<9);
			x = (x + 0xfd7046c5) + (x<<3);
			x = (x ^ 0xb55a4f09) ^ (x>>>16);
			return (x>>>0)/4294967295*2 - 1;
		};
		document.getElementById('seed').textContent = String(userSeed);
		// redraw from current view
		draw();
	}

	// Initialize
	resize();
	setSeed((Math.random()*1e9)|0);
	lastT = performance.now();
	requestAnimationFrame(loop);

	// Small optimization: redraw on visibility change to avoid CPU when backgrounded
	document.addEventListener('visibilitychange', ()=>{ if(document.hidden){} else draw(); });

	</script>
</body>
</html>