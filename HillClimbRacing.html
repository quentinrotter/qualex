<!doctype html>
<html lang="de">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Hill Climb Racing - Mini Clone</title>
	<style>
		html,body{height:100%;margin:0;background:#87CEEB;overflow:hidden;font-family:Inter,Segoe UI,Arial}
		canvas{display:block;background:linear-gradient(#87CEEB 0%, #b6e0ff 60%, #fff 100%)}
		#ui{position:fixed;left:12px;top:12px;color:#111;text-shadow:0 1px 0 rgba(255,255,255,0.6)}
		#ui .stats{background:rgba(255,255,255,0.9);padding:8px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.12)}
		#controls{position:fixed;right:12px;top:12px;text-align:right}
		.btn{background:rgba(0,0,0,0.5);color:white;padding:10px;border-radius:8px;margin:4px;display:inline-block;user-select:none}
		#bottomControls{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;display:flex;gap:10px}
		.touchBtn{width:64px;height:64px;background:rgba(0,0,0,0.45);border-radius:12px;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600}
		#message{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.65);color:#fff;padding:14px 20px;border-radius:8px;display:none}
		#instructions{position:fixed;left:12px;bottom:12px;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px}
	</style>
</head>
<body>
	<canvas id="c"></canvas>
	<div id="ui">
		<div class="stats" id="stats">
			<div>Speed: <span id="speed">0</span> km/h</div>
			<div>Distance: <span id="distance">0</span> m</div>
			<div>Fuel: <span id="fuel">100</span>%</div>
			<div>Score: <span id="score">0</span></div>
		</div>
	</div>
	<div style="position:fixed;right:12px;top:70px;text-align:right">
		<div class="btn" id="worldBtn">Hügelwelt</div>
	</div>
	<div id="controls">
		<div class="btn" id="restartBtn">Restart (R)</div>
	</div>
	<div id="bottomControls">
		<div class="touchBtn" id="leftBtn">◀</div>
		<div class="touchBtn" id="throttleBtn">↑</div>
		<div class="touchBtn" id="rightBtn">▶</div>
	</div>
	<div id="message"></div>
	<div id="instructions">Controls: Left/Right = tilt (in air). Up = throttle. R = restart. Mobile: use buttons.</div>

	<script>
	(function(){
		const canvas = document.getElementById('c');
		const ctx = canvas.getContext('2d');
		const speedEl = document.getElementById('speed');
		const distanceEl = document.getElementById('distance');
		const fuelEl = document.getElementById('fuel');
		const restartBtn = document.getElementById('restartBtn');
		const worldBtn = document.getElementById('worldBtn');
		const message = document.getElementById('message');

		let DPR = window.devicePixelRatio || 1;
		function resize(){
			DPR = window.devicePixelRatio || 1;
			canvas.width = Math.floor(innerWidth * DPR);
			canvas.height = Math.floor(innerHeight * DPR);
			canvas.style.width = innerWidth + 'px';
			canvas.style.height = innerHeight + 'px';
			ctx.setTransform(DPR,0,0,DPR,0,0);
		}
		addEventListener('resize', resize);
		resize();

		// seeded random
		function mulberry32(a){return function(){a |= 0; a = a + 0x6D2B79F5 | 0; var t = Math.imul(a ^ a>>>15, 1 | a); t = t + Math.imul(t ^ t>>>7, 61 | t) ^ t; return ((t ^ t>>>14) >>> 0) / 4294967296;}}
		const rand = mulberry32(123456);

		// Terrain generation - procedural
		const terrain = {points:[], step:10, length:200000};
		function generateTerrain(){
			terrain.points = [];
			const width = terrain.length;
			const step = terrain.step;
			// Choose a mode: 'hilly' produces larger, steeper hills
			const mode = terrain.mode || 'hilly';
			const sines = [];
			if(mode === 'hilly'){
				for(let i=0;i<6;i++) sines.push({amp:60 + rand()*150, freq: (0.0006 + rand()*0.003), phase: rand()*Math.PI*2});
			} else {
				for(let i=0;i<5;i++) sines.push({amp:20 + rand()*80, freq: (0.0005 + rand()*0.002), phase: rand()*Math.PI*2});
			}
			const hills = [];
			const hillCount = mode === 'hilly' ? 90 : 60;
			for(let h=0; h<hillCount; h++) hills.push({x: rand()*width, amp: (mode==='hilly'? -200 + rand()*450 : -100 + rand()*250), w: (mode==='hilly'? 300 + rand()*1200 : 400 + rand()*1500)});
			for(let x=0;x<=width;x+=step){
				let y = innerHeight*0.55 + (mode==='hilly'? 120*Math.sin(x*0.0008) : 80*Math.sin(x*0.001));
				for(const s of sines) y += Math.sin(x * s.freq + s.phase) * s.amp;
				for(const h of hills){
					y += h.amp * Math.exp(-Math.pow((x-h.x)/h.w,2));
				}
				// small noise
				y += (rand()-0.5)*40;
				terrain.points.push({x:x, y: y});
			}
		}
		generateTerrain();

		// Coins
		let coins = [];
		let score = 0;
		function generateCoins(){
			coins = [];
			// place coins along the first 'length' area spaced randomly
			for(let x=300; x<terrain.length-2000; x += 200 + Math.floor(rand()*600)){
				if(rand() < 0.85){
					const px = x + (rand()-0.5)*120;
					const ty = terrainHeight(px) - 60 - Math.floor(rand()*80);
					coins.push({x: px, y: ty, r: 12, collected: false, bob: rand()*Math.PI*2});
				}
			}
		}
		generateCoins();

		function terrainHeight(x){
			if(x<=0) return terrain.points[0].y;
			const step = terrain.step;
			const i = Math.floor(x/step);
			if(i >= terrain.points.length-1) return terrain.points[terrain.points.length-1].y;
			const a = terrain.points[i], b = terrain.points[i+1];
			const t = (x - a.x)/(b.x - a.x);
			return a.y*(1-t) + b.y*t;
		}
		function terrainSlope(x){
			const h1 = terrainHeight(x-1);
			const h2 = terrainHeight(x+1);
			return (h2-h1)/2;
		}

		// Car state
		let car = {};
		function reset(){
			car = {
				x: 120,
				y: terrainHeight(120) - 30,
				vx: 0,
				vy: 0,
				angle: 0,
				angularVelocity: 0,
				throttle: false,
				left: false,
				right: false,
				fuel: 100,
				distance: 0,
				crashed: false,
				airborne: false,
			};
			score = 0;
			message.style.display = 'none';
			lastTime = performance.now();
		}
		reset();

		// Controls
		const keys = {};
		addEventListener('keydown', (e)=>{
			if(e.key === 'ArrowUp' || e.key === 'w') car.throttle = true;
			if(e.key === 'ArrowLeft' || e.key === 'a') car.left = true;
			if(e.key === 'ArrowRight' || e.key === 'd') car.right = true;
			if(e.key === 'r' || e.key === 'R') reset();
		});
		addEventListener('keyup', (e)=>{
			if(e.key === 'ArrowUp' || e.key === 'w') car.throttle = false;
			if(e.key === 'ArrowLeft' || e.key === 'a') car.left = false;
			if(e.key === 'ArrowRight' || e.key === 'd') car.right = false;
		});

		// touch buttons
		function bindTouch(id, propOn, propOff){
			const el = document.getElementById(id);
			if(!el) return;
			function on(){ car[propOn] = true; el.style.background = 'rgba(0,128,0,0.6)'; }
			function off(){ car[propOn] = false; el.style.background = 'rgba(0,0,0,0.45)'; }
			el.addEventListener('touchstart', (e)=>{ e.preventDefault(); on(); });
			el.addEventListener('touchend', (e)=>{ e.preventDefault(); off(); });
			el.addEventListener('mousedown', ()=>on());
			el.addEventListener('mouseup', ()=>off());
			el.addEventListener('mouseleave', ()=>off());
		}
		bindTouch('throttleBtn','throttle');
		bindTouch('leftBtn','left');
		bindTouch('rightBtn','right');

		restartBtn.addEventListener('click', reset);
		// world button toggles terrain mode and regenerates
		if(worldBtn){
			worldBtn.addEventListener('click', ()=>{
				terrain.mode = terrain.mode === 'hilly' ? 'normal' : 'hilly';
				generateTerrain();
				generateCoins();
				reset();
				worldBtn.textContent = terrain.mode === 'hilly' ? 'Hügelwelt' : 'Flachwelt';
				showMessage('Welt neu erzeugt: ' + (terrain.mode === 'hilly' ? 'Hügelwelt' : 'Flachwelt'));
				setTimeout(()=> message.style.display='none', 1500);
			});
			// set initial label
			worldBtn.textContent = terrain.mode === 'hilly' ? 'Hügelwelt' : 'Flachwelt';
		}

		// Game constants
		const G = 1500; // gravity px/s^2 (large because px scale)
		const enginePower = 1600; // acceleration force equivalent
		const maxSpeed = 700; // px/s
		const friction = 0.95; // ground friction per second applied via velocity scaling
		const airDrag = 0.995;
		const carWidth = 120, carHeight = 36, groundClearance = 18;

		let lastTime = performance.now();

		function update(dt){
			if(car.crashed) return;
			// Controls effect
			if(car.throttle && car.fuel>0){
				const accel = enginePower / 60; // px/s^2 scaled a bit
				car.vx += accel * dt;
				car.fuel = Math.max(0, car.fuel - 10 * dt); // fuel consumption
			} else {
				// natural slow
				car.vx *= Math.pow(friction, dt);
			}
			// limit speed
			car.vx = Math.max(-maxSpeed, Math.min(maxSpeed, car.vx));

			// Horizontal motion
			car.x += car.vx * dt;
			car.distance = Math.max(car.distance, car.x);

			// Vertical / airborne detection
			const targetY = terrainHeight(car.x) - groundClearance - carHeight/2;
			// If currently airborne or not strictly touching ground
			if(car.y < targetY - 1 || Math.abs(car.vy) > 0.1){
				// airborne physics
				car.airborne = true;
				car.vy += G * dt;
				car.y += car.vy * dt;
				// rotation control in air
				if(car.left) car.angularVelocity -= 3 * dt;
				if(car.right) car.angularVelocity += 3 * dt;
				car.angle += car.angularVelocity * dt;
				// air drag on horizontal
				car.vx *= Math.pow(airDrag, dt*60);
			} else {
				// on ground: snap to terrain
				car.airborne = false;
				car.y = targetY;
				car.vy = 0;
				// align with slope smoothly
				const slope = terrainSlope(car.x);
				const targetAngle = Math.atan(slope);
				car.angle += (targetAngle - car.angle) * Math.min(1, 10*dt);
				// ground rotation momentum small
				car.angularVelocity *= 0.9;
				// wheel torque by leaning on throttle
				if(car.left) { car.angle -= 0.02; car.vx -= 10*dt; }
				if(car.right) { car.angle += 0.02; car.vx += 10*dt; }
			}

			// flip/crash detection - if car rotates too far for too long
			const angDeg = (car.angle*180/Math.PI + 360) % 360; // 0-360
			const normalized = angDeg > 180 ? angDeg - 360 : angDeg; // -180..180
			if(Math.abs(normalized) > 100){
				// crash
				car.crashed = true;
				showMessage('Crashed! Tap Restart (R)');
			}

			// Out of fuel behaviour
			if(car.fuel <= 0){
				car.throttle = false;
			}

			// coin collection
			for(const c of coins){
				if(c.collected) continue;
				const dx = c.x - car.x;
				const dy = c.y - car.y + carHeight*0.3; // adjust to car pickup point
				const dist = Math.sqrt(dx*dx + dy*dy);
				if(dist < 40){
					c.collected = true;
					score += 1;
					// small reward: give a little boost of fuel
					car.fuel = Math.min(100, car.fuel + 3);
				}
			}
		}

		function showMessage(txt){ message.style.display='block'; message.textContent = txt; }

		function draw(){
			// clear
			ctx.clearRect(0,0,canvas.width,canvas.height);
			const W = innerWidth, H = innerHeight;
			// camera
			const camX = car.x - W/3;
			const camY = 0;

			// sky gradient (redraw background)
			// terrain fill
			ctx.save();
			ctx.translate(-camX, 0);
			// draw terrain
			ctx.beginPath();
			const startIndex = Math.max(0, Math.floor(camX/terrain.step)-10);
			const endIndex = Math.min(terrain.points.length-1, Math.floor((camX+W)/terrain.step)+10);
			ctx.moveTo(terrain.points[startIndex].x, terrain.points[startIndex].y);
			for(let i=startIndex+1;i<=endIndex;i++) ctx.lineTo(terrain.points[i].x, terrain.points[i].y);
			ctx.lineTo(terrain.points[endIndex].x, H+200);
			ctx.lineTo(terrain.points[startIndex].x, H+200);
			ctx.closePath();
			ctx.fillStyle = '#5C8A2B';
			ctx.fill();
			// draw road details - stripes
			ctx.strokeStyle = '#3f6b20'; ctx.lineWidth = 2;
			ctx.beginPath();
			for(let i=startIndex+1;i<=endIndex;i+=6){
				ctx.moveTo(terrain.points[i].x, terrain.points[i].y);
				ctx.lineTo(terrain.points[i].x+terrain.step*2, terrain.points[i].y);
			}
			ctx.stroke();

			// draw coins (behind car)
			for(const c of coins){
				if(c.collected) continue;
				const bob = Math.sin((performance.now()/250) + c.bob) * 6;
				ctx.beginPath(); ctx.arc(c.x, c.y + bob, c.r, 0, Math.PI*2);
				const grad = ctx.createRadialGradient(c.x-4, c.y-4 + bob, 2, c.x, c.y + bob, c.r);
				grad.addColorStop(0, '#fff8b0'); grad.addColorStop(0.3, '#ffd44d'); grad.addColorStop(1, '#c88f00');
				ctx.fillStyle = grad; ctx.fill();
				ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1; ctx.stroke();
			}

			// draw car (body and wheels)
			const carScreenX = car.x;
			const carScreenY = car.y;
			ctx.save();
			ctx.translate(carScreenX, carScreenY);
			ctx.rotate(car.angle);
			// body
			ctx.fillStyle = '#ff3d3d';
			ctx.fillRect(-carWidth*0.5, -carHeight*0.5, carWidth, carHeight);
			// windows
			ctx.fillStyle = '#fff';
			ctx.fillRect(-carWidth*0.15, -carHeight*0.45, carWidth*0.3, carHeight*0.35);
			// wheels
			ctx.fillStyle = '#111';
			const wheelRad = 14;
			ctx.beginPath(); ctx.arc(-carWidth*0.3, carHeight*0.5, wheelRad, 0, Math.PI*2); ctx.fill();
			ctx.beginPath(); ctx.arc(carWidth*0.3, carHeight*0.5, wheelRad, 0, Math.PI*2); ctx.fill();
			ctx.restore();

			// HUD elements (finalize local transforms)
			// draw shadow under car (placeholder)
		
			// restore camera transform
			ctx.restore();

			// draw score into UI element (DOM)
			document.getElementById('score').textContent = score;
		}

		function loop(t){
			const now = t || performance.now();
			const dt = Math.min(0.05, (now - lastTime)/1000);
			lastTime = now;
			update(dt);
			draw();
			// update UI
			speedEl.textContent = Math.round(Math.abs(car.vx)*3.6);
			distanceEl.textContent = Math.floor(car.distance/1);
			fuelEl.textContent = Math.max(0, Math.floor(car.fuel));
			requestAnimationFrame(loop);
		}
		requestAnimationFrame(loop);

		// small helper: allow clicking canvas to toggle throttle (for quick testing)
		canvas.addEventListener('mousedown', ()=>{ car.throttle = true; });
		canvas.addEventListener('mouseup', ()=>{ car.throttle = false; });

		// debug: show message when out of map
		setInterval(()=>{
			if(car.x > terrain.length - 2000) showMessage('You reached the end! Restart to play again.');
		}, 2000);

		// expose reset for console
		window.hcrReset = reset;
	})();
	</script>
</body>
</html>
